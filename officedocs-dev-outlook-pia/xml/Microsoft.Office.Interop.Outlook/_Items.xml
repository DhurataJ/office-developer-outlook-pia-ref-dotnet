<Type Name="_Items" FullName="Microsoft.Office.Interop.Outlook._Items">
  <TypeSignature Language="C#" Value="public interface _Items : System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Items implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Items" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Items&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Items : System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("00063041-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>This is a primary interface in a COM coclass that is required by managed code for interoperability with the corresponding COM object. Use this primary interface only when the method you want to use shares the same name as an event of the COM object; in this case, cast to this interface to call the method, and cast to the latest events interface to connect to the event. Otherwise, use the .NET interface that is derived from the COM coclass to access methods, properties, and events of the COM object. For information about the COM object, see <see cref="T:Microsoft.Office.Interop.Outlook.Items" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public object Add (object Type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Add([in]object Type) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (Optional Type As Object) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(95)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Type" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Type">The Outlook item type for the new item. Specifies a <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.MessageClass" /> to create custom forms. Can be one of the following <b>OlItemType</b> constants: <b>olAppointmentItem</b>, <b>olContactItem</b>, <b>olJournalItem</b>, <b>olMailItem</b>, <b>olNoteItem</b>, <b>olPostItem</b>, or <b>olTaskItem,</b>, or any valid message class. </param>
        <summary>Creates a new Outlook item in the <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection for the folder. </summary>
        <returns>An Object value that represents the new Outlook item.</returns>
        <remarks>
          <para>If not specified, the <b>Type</b> property of the Outlook item defaults to the type of the folder or to <see cref="T:Microsoft.Office.Interop.Outlook.MailItem" /> if the parent folder is not typed.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an <see cref="T:Microsoft.Office.Interop.Outlook.Application" />  object that represents the parent Outlook application for the  object. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> constant indicating the object's class. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an <b>Integer</b> (<b>int</b> in C#) value indicating the count of objects in the specified collection. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public object Find (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Find([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (Filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Find(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(98)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">A string that specifies the criteria that the returned object must satisfy.</param>
        <summary>Locates and returns an Outlook item object that satisfies the given <paramref name="Filter" />.</summary>
        <returns>An Object value that represents an Outlook item if the call succeeds; returns <b>Nothing</b> (a null reference (Nothing in Visual Basic) in C#)  if it fails.  </returns>
        <remarks>
          <para>To use content indexing search in the <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection, use the <see cref="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" /> method. <b>FindRow</b> will return an error if <paramref name="Filter" /> contains content indexing keywords. For more information on content indexing keywords, see <a href="http://go.microsoft.com/fwlink/?LinkId=87947">Filtering Items Using Query Keywords</a></para>
          <para>The method will return an error with the following properties in the <paramref name="Filter" />: </para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Creating Filters for the Find and Restrict Methods</para>
          <para>The syntax for the filter varies depending on the type of field you are filtering on. </para>
          <para>String (for Text fields) </para>
          <para>When searching Text fields, you can use either an apostrophe (') or  double quotation marks ("") to delimit the values that are part of the filter. For example, all of the following lines function correctly when the field is of type <b>String</b> (<b>string</b> in C#): </para>
          <para>sFilter = "[CompanyName] = 'Microsoft'" </para>
          <para>sFilter = "[CompanyName] = ""Microsoft""" </para>
          <para>sFilter = "[CompanyName] = " &amp; Chr(34) &amp; "Microsoft" &amp; Chr(34)</para>
          <para>In specifying a filter in a Jet or DASL query, if you use a pair of single quotes to delimit a string that is part of the filter, and the string contains another single quote or apostrophe, then add a single quote as an escape character before the single quote or apostrophe. Use a similar approach if you use a pair of double quotes to delimit a string. If the string contains a double quote, then add a double quote as an escape character before the double quote.</para>
          <para>For example, in the DASL filter string that filters for the <b>Subject</b> property being equal to the word can't, the entire filter string is delimited by a pair of double quotes, and the embedded string can't is delimited by a pair of single quotes. There are three characters that you need to escape in this filter string: the starting double quote and the ending double quote for the property reference of http://schemas.microsoft.com/mapi/proptag/0x0037001f, and the apostrophe in the value condition for the word can't. Applying the appropriate escape characters, you can express the filter string as follows:</para>
          <para>filter = "@SQL=""http://schemas.microsoft.com/mapi/proptag/0x0037001f"" = 'can''t'"</para>
          <para>Alternatively, you can use the chr(34) function to represent the double quote (whose ASCII character value is 34) that is used as an escape character. Using the chr(34) substitution for a double-quote escape character, you can express the last example as follows:</para>
          <para>filter = "@SQL= " &amp; Chr(34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001f" _</para>
          <para>    &amp; Chr(34) &amp; " = " &amp; "'can''t'"</para>
          <para>Escaping single and double quote characters is also required for DASL queries with the <b>ci_startswith</b> or <b>ci_phrasematch</b> operators. For example, the following query performs a phrase match query for can't in the message subject: </para>
          <para>filter = "@SQL=" &amp; Chr(34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001E" _</para>
          <para>    &amp; Chr(34) &amp; " ci_phrasematch " &amp; "'can''t'"</para>
          <para>Another example is a DASL filter string that filters for the <b>Subject</b> property being equal to the words the right stuff, where the word stuff is enclosed by double quotes. In this case, you must escape the enclosing double quotes as follows:</para>
          <para>filter = "@SQL=""http://schemas.microsoft.com/mapi/proptag/0x0037001f"" = 'the right ""stuff""'"</para>
          <para>A different set of escaping rules apply to a property reference for named properties that contain the space, single quote, double quote, or percent character. For more information, see Referencing Properties by Namespace.</para>
          <para>Date</para>
          <para>Although dates and times are typically stored with a Date format, the Find and Restrict methods require that the date and time be converted to a string representation. To make sure that the date is formatted as Microsoft Outlook expects, use the Format function. The following example creates a filter to find all contacts that have been modified after January 15, 1999 at 3:30 P.M. </para>
          <para>sFilter = "[LastModificationTime] &gt; '" &amp; Format("1/15/99 3:30pm", "ddddd h:nn AMPM") &amp; "'"</para>
          <para>Boolean Operators</para>
          <para>Boolean operators, TRUE/FALSE, YES/NO, ON/OFF, and so on, should not be converted to a string. For example, to determine whether journaling is enabled for contacts, you can use this filter: </para>
          <para>sFilter = "[Journal] = True" </para>
          <para>
            <b>Note</b>: If you use quotation marks as delimiters with Boolean fields, then an empty string will find items whose fields are False and all non-empty strings will find items whose fields are True.</para>
          <para>Keywords (or Categories)</para>
          <para>The Categories field is of type keywords, which is designed to hold multiple values. When accessing it programmatically, the Categories field behaves like a Text field, and the string must match exactly. Values in the text string are separated by a comma and a space. This typically means that you cannot use the Find and Restrict methods on a keywords field if it contains more than one value. For example, if you have one contact in the Business category and one contact in the Business and Social categories, you cannot easily use the Find and Restrict methods to retrieve all items that are in the Business category. Instead, you can loop through all contacts in the folder and use the Instr function to test whether the string "Business" is contained within the entire keywords field. </para>
          <para>
            <b>Note</b>: A possible exception is if you limit the Categories field to two, or a low number of values. Then you can use the Find and Restrict methods with the OR logical operator to retrieve all Business contacts. For example (in pseudocode): "Business" OR "Business, Personal" OR "Personal, Business." Category strings are not case sensitive.</para>
          <para>Integer</para>
          <para>You can search for Integer fields with or without quotation marks as delimiters. The following filters will find contacts that were created with  Outlook 2000: </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = '92711'"</para>
          <para>Using Variables as Part of the Filter</para>
          <para>As the Restrict method example illustrates, you can use values from variables as part of the filter. The following Microsoft Visual Basic code sample illustrates syntax that uses variables as part of the filter. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para> This approach uses Chr(34) to delimit the value: sFilter = "[FullName] = " &amp; Chr(34) &amp; sFullName &amp; Chr(34) </para>
          <para> This approach uses double quotation marks to delimit the value: sFilter = "[FullName] = """ &amp; sFullName &amp; """"</para>
          <para>Using Logical Operators as Part of the Filter</para>
          <para>Logical operators that are allowed are AND, OR, and NOT. The following are variations of the clause for the Restrict method, so you can specify multiple criteria.  </para>
          <para>OR: The following code returns all contact items that have either Business or Personal as their category. </para>
          <para>sFilter = "[Categories] = 'Personal' Or [Categories] = 'Business'" </para>
          <para>AND: The following code retrieves all personal contacts who work at Microsoft. </para>
          <para>sFilter = "[Categories] = 'Personal' And [CompanyName] = 'Microsoft'" </para>
          <para>NOT: The following code retrieves all personal contacts who don't work at Microsoft. </para>
          <para>sFilter = "[Categories] = 'Personal' And Not([CompanyName] = 'Microsoft')"</para>
          <para>Additional Notes</para>
          <para>If you are trying to use the Find or Restrict methods with user-defined fields, the fields must be defined in the folder, otherwise an error will occur. There is no way to perform a "contains" operation. For example, you cannot use Find or Restrict to search for items that have a particular word in the Subject field. Instead, you can use the AdvancedSearch method, or you can loop through all of the items in the folder and use the InStr function to perform a search within a field. You can use the Restrict method to search for items that begin within a certain range of characters. For example, to search for all contacts with a last name beginning with the letter M, use this filter: </para>
          <para>sFilter = "[LastName] &gt; 'LZZZ' And [LastName] &lt; 'N'"</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNext">
      <MemberSignature Language="C#" Value="public object FindNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(99)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>After the <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />  method runs, this method finds and returns the next Outlook item in the specified collection.</summary>
        <returns>An Object value that represents the next Outlook item found in the collection.</returns>
        <remarks>
          <para> The search operation begins from the current position, which matches the expression previously set through the <b>Find</b> method.</para>
          <para>The method returns an Outlook item object if the call succeeds; it returns <b>Nothing</b> (a null reference (Nothing in Visual Basic) in C#) if it fails.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirst">
      <MemberSignature Language="C#" Value="public object GetFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFirst() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirst () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(86)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the first object in the collection. </summary>
        <returns>An Object value that represents the first object contained by the collection.</returns>
        <remarks>
          <para>Returns <b>Nothing</b> if no first object exists, for example, if there are no objects in the collection.To ensure correct operation of the <b>GetFirst</b>, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, and <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> methods in a large collection, call <b>GetFirst</b> before calling <b>GetNext</b> on that collection and call <b>GetLast</b> before calling <b>GetPrevious</b>. To ensure that you are always making the calls on the same collection, create an explicit variable that refers to that collection before entering the loop.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLast">
      <MemberSignature Language="C#" Value="public object GetLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLast() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLast () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(88)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the last object in the collection. </summary>
        <returns>An Object value that represents the last object contained by the collection.</returns>
        <remarks>
          <para>It returns <b>Nothing</b> if no last object exists, for example, if the collection is empty.To ensure correct operation of the <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <b>GetLast</b>, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, and <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> methods in a large collection, call <b>GetFirst</b> before calling <b>GetNext</b> on that collection, and call <b>GetLast</b> before calling <b>GetPrevious</b>. To ensure that you are always making the calls on the same collection, create an explicit variable that refers to that collection before entering the loop.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNext">
      <MemberSignature Language="C#" Value="public object GetNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(87)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the next object in the collection. </summary>
        <returns>An Object value that represents the next object contained by the collection.</returns>
        <remarks>
          <para>It returns <b>Nothing</b> if no next object exists, for example, if already positioned at the end of the collection.To ensure correct operation of the <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <b>GetNext</b>, and <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> methods in a large collection, call <b>GetFirst</b> before calling <b>GetNext</b> on that collection, and call <b>GetLast</b> before calling <b>GetPrevious</b>. To ensure that you are always making the calls on the same collection, create an explicit variable that refers to that collection before entering the loop.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrevious">
      <MemberSignature Language="C#" Value="public object GetPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetPrevious() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPrevious () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(89)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the previous object in the collection. </summary>
        <returns>An Object value that represents the previous object contained by the collection.</returns>
        <remarks>
          <para>It returns <b>Nothing</b> if no previous object exists, for example, if already positioned at the beginning of the collection.To ensure correct operation of the <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, and <b>GetPrevious</b> methods in a large collection, call <b>GetFirst</b> before calling <b>GetNext</b> on that collection, and call <b>GetLast</b> before calling <b>GetPrevious</b>. To ensure that you are always making the calls on the same collection, create an explicit variable that refers to that collection before entering the loop.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeRecurrences">
      <MemberSignature Language="C#" Value="public bool IncludeRecurrences { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeRecurrences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.IncludeRecurrences" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeRecurrences As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeRecurrences { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a <b>Boolean</b> (<b>bool</b> in C#) that indicates <b>True</b> if the <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection should include recurrence patterns. Read/write.</summary>
        <value>To be added.</value>
        <remarks>
          <para>This property only has an effect if the <b>Items</b> collection contains appointments and is not sorted by any property other than <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.Start" /> in ascending order. The default value is <b>False</b>. Use this property when you want to retrieve all appointments for a given date, where recurring appointments would not normally appear because they are not associated with any specific date. If you need to sort and filter on appointment items that contain recurring appointments, you must do so in this order: sort the items in ascending order, set <b>IncludeRecurrences</b> to <b>True</b>, and then filter the items. For a code sample showing this order, see the second example below. If the collection includes recurring appointments with no end date, setting the property to <b>True</b> may cause the collection to be of infinite count. Be sure to include a test for this in any loop. You should not use <b>Count</b> property of <b>Items</b> collection when iterating <b>Items</b> collection with <b>IncludeRecurrence</b> property set to <b>True</b>. The value of <b>Count</b> will be an undefined value.</para>
          <para>
            <b>Caution</b>: Filtering on a sorted list of occurrences will cause the IncludeRecurrences property not to work as expected. For example, the following sequence will return all appointment occurrences; recurring and non-recurring: (1) Sort by Start property (2) Set property to false (3) call Restrict (i.e., filter).</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">Either the index number of the object, or a value used to match the default property of an object in the collection.</param>
        <summary>Returns an Outlook item from a collection.</summary>
        <value>An Object value that represents the specified object.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the parent <b>Object</b> of the specified object. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawTable">
      <MemberSignature Language="C#" Value="public object RawTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object RawTable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.RawTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawTable As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ RawTable { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.TypeLibFunc(64)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This object, member, or enumeration is deprecated and is not intended to be used in your code.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove([in]int32 Index) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(84)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">The 1-based index value of the object within the collection.</param>
        <summary>Removes an object from the collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetColumns">
      <MemberSignature Language="C#" Value="public void ResetColumns ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetColumns() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.ResetColumns" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetColumns ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetColumns();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(93)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the properties that have been cached with the <see cref="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" /> method. </summary>
        <remarks>
          <para>All properties are accessible after calling the <b>ResetColumns</b> method. <b>SetColumns</b> should be reused to store new properties again. <b>ResetColumns</b> does nothing if <b>SetColumns</b> has not been called first.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restrict">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Items Restrict (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Office.Interop.Outlook.Items Restrict([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Restrict (Filter As String) As Items" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Office::Interop::Outlook::Items ^ Restrict(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(100)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Items</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">A filter string expression to be applied. For details, see the <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />  method.</param>
        <summary>Applies a filter to the <see cref="T:Microsoft.Office.Interop.Outlook.Items" />  collection, returning a new collection containing all of the items from the original that match the filter.</summary>
        <returns>An <b>Items</b> collection that represents the items from the original <b>Items</b> collection which match the filter.</returns>
        <remarks>
          <para>This method is an alternative to using the <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />  method or <see cref="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />  method to iterate over specific items within a collection. The <b>Find</b> or <b>FindNext</b> methods are faster than filtering if there are a small number of items. The <b>Restrict</b> method is significantly faster if there is a large number of items in the collection, especially if only a few items in a large collection are expected to be found.</para>
          <para>
            <b>Note</b>: If you are using user-defined fields as part of a <b>Find</b> or <b>Restrict</b> clause, the user-defined fields must exist in the folder. Otherwise the code will generate an error stating that the field is unknown. You can add a field to a folder by displaying the Field Chooser and clicking New.</para>
          <para>This method cannot be used and will cause an error with the following properties:</para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Creating Filters for the Find and Restrict Methods</para>
          <para>The syntax for the filter varies depending on the type of field you are filtering on. </para>
          <para>String (for Text fields) </para>
          <para>When searching Text fields, you can use either an apostrophe ('), or  double quotation marks (""), to delimit the values that are part of the filter. For example, all of the following lines function correctly when the field is of type <b>String</b> (<b>string</b> in C#): </para>
          <para>sFilter = "[CompanyName] = 'Microsoft'" </para>
          <para>sFilter = "[CompanyName] = ""Microsoft""" </para>
          <para>sFilter = "[CompanyName] = " &amp; Chr(34) &amp; "Microsoft" &amp; Chr(34)</para>
          <para>In specifying a filter in a Jet or DASL query, if you use a pair of single quotes to delimit a string that is part of the filter, and the string contains another single quote or apostrophe, then add a single quote as an escape character before the single quote or apostrophe. Use a similar approach if you use a pair of double quotes to delimit a string. If the string contains a double quote, then add a double quote as an escape character before the double quote.</para>
          <para>For example, in the DASL filter string that filters for the <b>Subject</b> property being equal to the word can't, the entire filter string is delimited by a pair of double quotes, and the embedded string can't is delimited by a pair of single quotes. There are three characters that you need to escape in this filter string: the starting double quote and the ending double quote for the property reference of http://schemas.microsoft.com/mapi/proptag/0x0037001f, and the apostrophe in the value condition for the word can't. Applying the appropriate escape characters, you can express the filter string as follows:</para>
          <para>filter = "@SQL=""http://schemas.microsoft.com/mapi/proptag/0x0037001f"" = 'can''t'"</para>
          <para>Alternatively, you can use the chr(34) function to represent the double quote (whose ASCII character value is 34) that is used as an escape character. Using the chr(34) substitution for a double-quote escape character, you can express the last example as follows:</para>
          <para>filter = "@SQL= " &amp; Chr(34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001f" _</para>
          <para>    &amp; Chr(34) &amp; " = " &amp; "'can''t'"</para>
          <para>Escaping single and double quote characters is also required for DASL queries with the <b>ci_startswith</b> or <b>ci_phrasematch</b> operators. For example, the following query performs a phrase match query for can't in the message subject: </para>
          <para>filter = "@SQL=" &amp; Chr(34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001E" _</para>
          <para>    &amp; Chr(34) &amp; " ci_phrasematch " &amp; "'can''t'"</para>
          <para>Another example is a DASL filter string that filters for the <b>Subject</b> property being equal to the words the right stuff, where the word stuff is enclosed by double quotes. In this case, you must escape the enclosing double quotes as follows:</para>
          <para>filter = "@SQL=""http://schemas.microsoft.com/mapi/proptag/0x0037001f"" = 'the right ""stuff""'"</para>
          <para>A different set of escaping rules apply to a property reference for named properties that contain the space, single quote, double quote, or percent character. For more information, see Referencing Properties by Namespace.</para>
          <para>Date</para>
          <para>Although dates and times are typically stored with a Date format, the <b>Find</b> and <b>Restrict</b> methods require that the date and time be converted to a string representation. To make sure that the date is formatted as Microsoft Outlook expects, use the <b>Format</b> function. The following example creates a filter to find all contacts that have been modified after January 15, 1999 at 3:30 P.M. </para>
          <para>sFilter = "[LastModificationTime] &gt; '" &amp; Format("1/15/99 3:30pm", "ddddd h:nn AMPM") &amp; "'"</para>
          <para>Boolean Operators</para>
          <para>Boolean operators, TRUE/FALSE, YES/NO, ON/OFF, and so on, should not be converted to a string. For example, to determine whether journaling is enabled for contacts, you can use this filter: </para>
          <para>sFilter = "[Journal] = True" </para>
          <para>
            <b>Note</b>: If you use quotation marks as delimiters with <b>Boolean</b> fields, then an empty string will find items whose fields are <b>False</b> and all non-empty strings will find items whose fields are <b>True</b>. </para>
          <para>Keywords (or Categories)</para>
          <para>The Categories field is of type keywords, which is designed to hold multiple values. When accessing it programmatically, the Categories field behaves like a Text field, and the string must match exactly. Values in the text string are separated by a comma and a space. This typically means that you cannot use the <b>Find</b> and <b>Restrict</b> methods on a keywords field if it contains more than one value. For example, if you have one contact in the Business category and one contact in the Business and Social categories, you cannot easily use the <b>Find</b> and <b>Restrict</b> methods to retrieve all items that are in the Business category. Instead, you can loop through all contacts in the folder and use the <b>Instr</b> function to test whether the string "Business" is contained within the entire keywords field. </para>
          <para>
            <b>Note</b>: A possible exception is if you limit the Categories field to two, or a low number of values. Then you can use the <b>Find</b> and <b>Restrict</b> methods with the OR logical operator to retrieve all Business contacts. For example (in pseudocode): "Business" OR "Business, Personal" OR "Personal, Business." Category strings are not case sensitive. </para>
          <para>Integer</para>
          <para>You can search for <b>Integer</b> fields with, or without quotation marks as delimiters. The following filters will find contacts that were created using  Outlook 2000: </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = '92711'"</para>
          <para>Using Variables as Part of the Filter</para>
          <para>As the <b>Restrict</b> method example illustrates, you can use values from variables as part of the filter. The following Microsoft Visual Basic code sample illustrates syntax that uses variables as part of the filter. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para>' This approach uses Chr(34) to delimit the value. </para>
          <para>sFilter = "[FullName] = " &amp; Chr(34) &amp; sFullName &amp; Chr(34) </para>
          <para>' This approach uses double quotation marks to delimit the value. </para>
          <para>sFilter = "[FullName] = """ &amp; sFullName &amp; """"</para>
          <para>Using Logical Operators as Part of the Filter</para>
          <para>Logical operators that are allowed are AND, OR, and NOT. The following are variations of the clause for the <b>Restrict</b> method so you can specify multiple criteria.  </para>
          <para>OR: The following code returns all contact items that have either Business or Personal as their category. </para>
          <para>sFilter = "[Categories] = 'Personal' Or [Categories] = 'Business'" </para>
          <para>AND: The following code retrieves all personal contacts who work at Microsoft. </para>
          <para>sFilter = "[Categories] = 'Personal' And [CompanyName] = 'Microsoft'" </para>
          <para>NOT: The following code retrieves all personal contacts who don't work at Microsoft. </para>
          <para>sFilter = "[Categories] = 'Personal' And Not([CompanyName] = 'Microsoft')"</para>
          <para>Additional Notes</para>
          <para>If you are trying to use the <b>Find</b> or <b>Restrict</b> methods with user-defined fields, the fields must be defined in the folder, otherwise an error will occur. There is no way to perform a "contains" operation. For example, you cannot use <b>Find</b> or <b>Restrict</b> to search for items that have a particular word in the Subject field. Instead, you can use the <see cref="M:Microsoft.Office.Interop.Outlook._Application.AdvancedSearch(System.String,System.Object,System.Object,System.Object)" /> method, or you can loop through all of the items in the folder and use the <b>InStr</b> function to perform a search within a field. You can use the <b>Restrict</b> method to search for items that begin within a certain range of characters. For example, to search for all contacts with a last name beginning with the letter M, use this filter: </para>
          <para>sFilter = "[LastName] &gt; 'LZZZ' And [LastName] &lt; 'N'"</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" />  object for the current session. Read-only.</summary>
        <value>To be added.</value>
        <remarks>
          <para>The <b>Session</b> property and the <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> method can be used interchangeably to obtain the <b>NameSpace</b> object for the current session. Both members serve the same purpose. For example, the following pairs of statements perform the same function:</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetColumns">
      <MemberSignature Language="C#" Value="public void SetColumns (string Columns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetColumns([in]string Columns) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetColumns (Columns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetColumns(System::String ^ Columns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(92)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Columns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Columns">A string that contains the names of the properties to cache. The property names are delimited by commas in this string.</param>
        <summary>Caches certain properties for extremely fast access to those particular properties of an item within the collection. </summary>
        <remarks>
          <para>The <b>SetColumns</b> method is useful for iterating through the <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection. If you don't use this method, Microsoft Outlook must open each item to access the property. With the <b>SetColumns</b> method, Outlook only checks the properties that you have cached, and provides fast, read-only access to these properties.</para>
          <para>After applying the <b>SetColumns</b> method on specific properties of the collection, you cannot read other properties of that collection; properties which are not cached are returned empty. You cannot write to any of the properties of that collection either. Alternatively, if you require read-write, fast access to a set of items, use the <see cref="T:Microsoft.Office.Interop.Outlook.Table" /> object.</para>
          <para>
            <b>SetColumns</b> cannot be used, and will cause an error, with any property that returns an object. It cannot be used with the following properties:</para>
          <list type="table">
            <item>
              <description>AutoResolvedWinner</description>
              <description>InternetCodePage</description>
            </item>
            <item>
              <description>Body</description>
              <description>MeetingWorkspaceURL</description>
            </item>
            <item>
              <description>BodyFormat</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>Categories</description>
              <description>ReceivedByEntryID</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>ReceivedOnBehalfOfEntryID</description>
            </item>
            <item>
              <description>Class</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>Companies</description>
              <description>ReplyRecipients</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>DownloadState</description>
              <description>Saved</description>
            </item>
            <item>
              <description>EntryID</description>
              <description>Sent</description>
            </item>
            <item>
              <description>HTMLBody</description>
              <description>Submitted</description>
            </item>
            <item>
              <description>IsConflict</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.VotingOptions" />
              </description>
            </item>
          </list>
          <para>The <b>ConversationIndex</b> property cannot be cached using the <b>SetColumns</b> method. However, this property will not result in an error like the other properties listed above.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (string Property, object Descending);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort([in]string Property, [in]object Descending) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Sort(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (Property As String, Optional Descending As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(97)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Property" Type="System.String" />
        <Parameter Name="Descending" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Property">The name of the property by which to sort, which may be enclosed in brackets, for example, "[CompanyName]". User-defined properties that contain spaces must be enclosed in brackets. May not be a user-defined property of type keywords, and may not be a multi-valued property, such as a category. For user-defined properties, the property must exist in the <b>UserDefinedProperties</b> collection for <see cref="P:Microsoft.Office.Interop.Outlook._Items.Parent" />, which represents the <see cref="T:Microsoft.Office.Interop.Outlook.Folder" /> object that contains the items. </param>
        <param name="Descending">
          <b>True</b> to sort in descending order. The default value is <b>False</b> (ascending).</param>
        <summary>Sorts the collection of items by the specified property. The index for the collection is reset to 1 upon completion of this method.</summary>
        <remarks>
          <para>
            <b>Sort</b> only affects the order of items in a collection. It does not affect the order of items in an explorer view.</para>
          <para>
            <b>Sort</b> cannot be used and will cause an error if the <paramref name="property" /> paramater is one of the following properties:                </para>
          <list type="table">
            <item>
              <description>
                <b>Categories</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnly" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnlyCompany" />
              </description>
            </item>
            <item>
              <description>
                <b>Class</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstNoSpace" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.NetMeetingAlias" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstSpaceOnly" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstAndSuffix" />
              </description>
              <description>
                <b>Saved</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpace" />
              </description>
              <description>
                <b>Sent</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpaceCompany" />
              </description>
              <description />
            </item>
          </list>
          <para />
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
